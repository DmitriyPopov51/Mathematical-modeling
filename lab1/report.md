# Отчет по лабораторной работе №1. Работа с git

## 02.03.02 - Математическое моделирование

## Выполнил: Попов Дмитрий Павлович НФИбд-03-19 1032191646

## Задание: 
    Необходимо ознакомиться с основными возможностями git, а также научиться работать с markdown

### 1.1 Подготовка 
Для начала мне нужно подготовить окружение. Для этого я устанавливаю имя и e-mail пользователя, от которого будет вестись работа. Также выставляем параметры для корректной работы с текстовыми файлами (в зависимости от типа ОС). 

![img1](screenshots/img1.png "подготовка") 

### 1.2 Создание проекта 
Создаю проект hello, в котором создаю файл hello.html. Записываю в этот файл какой-либо текст. После этого делаю данный проект репозиторием, добавляю изменения в индекс и делаю коммит. Проверяю текущее состояние репозитория. 

![img2](screenshots/img2.png "создание проекта") 

### 1.3 Внесение изменений 
Изменим наш текст. Проверим состояние репозитория - изменения не добавлены в индекс. 

![img3.1](screenshots/img3.1.png "hello.html") 

![img3.2](screenshots/img3.2.png "git status")

### 1.4 Индексация изменений 
Добавляем и смотрим снова. После этого совершаем коммит, только в этот раз без параметра -m, т.е. пишем комментарий в текстовом редакторе. Смотрим состояние - нет необработанных изменений. 

![img4.1](screenshots/img4.1.png "git add") 

![img4.2](screenshots/img4.2.png "vim") 

![img4.3](screenshots/img4.3.png "git status") 

Изменим наш текст еще раз, добавим изменения в индекс. После этого снова изменяем текст и смотрим состояние - наш файл отмечем дважды - одно изменение в индексе и готово к коммиту, второе - нет. 
Делаем коммит и смотрим статус - есть новые изменения. Добавляем оставшиеся изменения в индекс и проверяем статус. После совершаем коммит.

![img4.4](screenshots/img4.4.png "hello.html") 

![img4.5](screenshots/img4.5.png "git status и commit") 

Просматриваем совершенные изменения. 

![img4.6](screenshots/img4.6.png "git log") 

Выберем какой-либо предыдущий коммит, запомним его хэш-код и с помощью команды checkout и хэша скопируем его в рабочий репозиторий. Проверим содержимое нашего файла на данном коммите - оно отличается от текущего. 

![img4.7](screenshots/img4.7.png "git checkout") 

Вернемся к последней (текущей) версии при помощи git checkout master и проверим содержимое файла для достоверности. 

![img4.8](screenshots/img4.8.png "git checkout master") 

Создадим тег для текущей версии страницы hello - назовем его v1. Перейдем на предыдущую версию изменений и проверим содержимое файла. Установим тег и на эту версию - v1-beta. 
Просматриваем все теги разными способами. 

![img4.9](screenshots/img4.9.png "git tag") 

![img4.10](screenshots/img4.10.png "git tag") 

### 1.5 Отмена локальных изменений (до индексации) 
Перейдем в последнюю версию изменений, и изменим наш файл. Мы нонимаем, что это изменение нам не нужно. Смотрим состояние - файл изменен. 

![img5.1](screenshots/img5.1.png "ветка master") 

![img5.2](screenshots/img5.2.png "hello.html") 

Для отмены изменений воспользуемся git checkout hello.html, смотрим - изменений нет. 

![img5.3](screenshots/img5.3.png "отмена изменений") 

### 1.6 Отмена проиндексированных изменений (перед коммитом) 
Воссоздаем предыдущую ситуацию, только в этот раз добавим изменения в индекс. 
Чтобы отменить нежелательные изменения в этом случае, воспользуемся командой git reset HEAD hello.html, а затем тем же алгоритмом, что и на предыдущем шаге. 

![img6.1](screenshots/img6.1.png "консоль")

![img6.2](screenshots/img6.2.png "hello.html")

### 1.7 Отмена коммитов 
Теперь изменим файл и сделаем его нежелательный коммит. Для его отмены сделаем еще один коммит, отменяющий предыдущий. Проверяем логи. 

![img7.1](screenshots/img7.1.png "commit") 

![img7.2](screenshots/img7.2.png "hello.html") 

![img7.3](screenshots/img7.3.png "git log")

### 1.8 Удаление коммиттов из ветки 
Мы видим, что хоть мы и отменили коммит, в логах они остались - удалим их при помощи сборщика мусора. Отметим эту ветку тегом oops. Сбросим коммит к предыдущему тегу v1 и проверим логи. 

![img8.1](screenshots/img8.1.png "git tag oops") 

Даже после этого удаленные коммиты можно увидеть в расширенных логах. 

![img8.2](screenshots/img8.2.png "git log") 
 
### 1.9 Удаление тега oops 
Удалим тег oops и проверим историю коммитов - сейчас там нет нежелательных коммитов. 

![img9](screenshots/img9.png "git tag -d oops")

### 1.10 Внесение изменений в коммиты 
Добавил в страницу комментарии автора и закоммитил 
Далее, решил добавить email и чтобы не создавать отдельный коммит, я изменил предыдущий 

![img10.1](screenshots/img10.1.png "commit") 

![img10.2](screenshots/img10.2.png "hello.html") 

И в истории можно увидеть, что коммит только один 

![img10.3](screenshots/img10.3.png "git log") 

### 1.11 Перемещение файлов 
Перемещаю файл hello.html в каталог lib 

![img11](screenshots/img11.png "git mv")

### 1.12 Второй способ перемещения файлов
Посмотрел второй вариант перемещения файлов, который идентичен предыдущему пункту, а также сделал коммит этого перемещения.

![img12](screenshots/img12.png "commit")

### 1.13 Подробнее о структуре
Добавил файл index.html и сделал коммит

![img13.1](screenshots/img13.1.png "консоль")

![img13.2](screenshots/img13.2.png "index.html")

### 1.14 Git внутри: Каталог .git
Просмотрел каталог .git, базу данных объектов, состоющую из каталогов с именем из двух символов, и углубился в эти каталоги.

![img14.1](screenshots/img14.1.png "dir -C .git")

![img14.2](screenshots/img14.2.png "dir -C .git\objects")

Также просмотрел файл конфигурации, ветки и теги, и файл HEAD.

![img14.3](screenshots/img14.3.png "config")

![img14.4](screenshots/img14.4.png "refs")

### 1.15 Работа непосредственно с объектами git
Вывел на экран последний коммит в репозитории командой git log --max-count=1, вывел последний коммит с помощью SHA1 хэша, затем вывел дерево каталогов, ссылку на который взял в коммите. После этого вывел каталог lib, файл hello.html

![img15](screenshots/img15.png "git cat-file")

### 1.16 Создание ветки
Чтобы сделать hello world более выразительным, создал новую ветку style, добавил файл стилей style.css, изменил основную страницу hello.html, чтобы использовать стили, обновил файл index.html, чтобы он тоже использовал style.css.

![img16.1](screenshots/img16.1.png "style.css")

![img16.2](screenshots/img16.2.png "hello.html")

![img16.3](screenshots/img16.3.png "index.html")

![img16.4](screenshots/img16.4.png "ветка style")

![img16.5](screenshots/img16.5.png "commit")

### 1.17 Навигация по веткам
Так как у нас теперь есть две ветки, для начала я переключился на ветку master, просмотрел файл hello.html без стилей, затем вернулся к ветке style и просмотрел файл hello.html, в котором есть стили.

![img17.1](screenshots/img17.1.png "git log")

![img17.2](screenshots/img17.2.png "checkout")

### 1.18 Изменения в ветке master
Создал файл README.md и записал туда строку

![img18](screenshots/img18.png "README.md")

### 1.19 Коммит изменений README.md в ветку master
Сделал коммит изменений README.md, просмотрел текущие ветки и их отличия лог-командой git log --graph --all. Команда вызывает построение дерева коммитов с помощью простых ASCII символов, а -all означает, что мы видим все ветки.

![img19.1](screenshots/img19.1.png "commit")

![img19.2](screenshots/img19.2.png "git log")

### 1.20 Слияние
Вернулся к ветке style и выполнил слияние master с style. Таким образом перенес изменения из двух веток в одну

![img20.1](screenshots/img20.1.png "merge")

![img20.2](screenshots/img20.2.png "git log")

### 1.21 Создание конфликта
Вернулся в ветку master и внес изменения в файл hello.html, сделал коммит. Затем просмотрел логи веток, последнее изменение в master конфликтует с некоторыми изменениями в style.

![img21.1](screenshots/img21.1.png "commit")

![img21.2](screenshots/img21.2.png "hello.html")

![img21.3](screenshots/img21.3.png "git log")

### 1.22 Разрешение конфликтов
Вернулся к ветке style и попытался объединить ее с новой веткой master, возник конфликт. Открыл файл hello.html и вручную разрешил конфликт. Затем сделал коммит решения конфликта.

![img22.1](screenshots/img22.1.png "commit")

![img22.2](screenshots/img22.2.png "hello.html - конфликт")

![img22.3](screenshots/img22.3.png "hello.html - разрешенный конфликт")

### 1.23 Сброс ветки style
Вернулся к ветке style в точку перед слиянием с master, нашел последний коммит перед слиянием и сбросил ветку style к этому коммиту. Затем проверил ветку, в логах нет коммитов слияний.

![img23.1](screenshots/img23.1.png "git log --graph")

![img23.2](screenshots/img23.2.png "git reset")

### 1.24 Сброс ветки master
Вернулся к ветке master перед внесением конфликтующих изменений. Нашел коммит "Added README" и сбросил ветку к этому коммиту.

![img24.1](screenshots/img24.1.png "git checkout master")

![img24.2](screenshots/img24.2.png "git reset --hard")

### 1.25 Перебазирование 
В данном пункте я использую команду rebase, вместо команды merge. И хочу перенести изменения из ветки master в ветку style. 

![img25](screenshots/img25.png "git rebase") 

Конечный результат перебазирования очень похож на результат слияния.Однако, дерево коммитов значительно отличается. Дерево коммитов ветки style было переписано таким образом, что ветка master является 
частью истории коммитов. Это делает цепь коммитов линейной и гораздо более читабельной. 
Рекомендуется использовать git rebase для кратковременных, локальных веток, а слияние для веток в публичном 
репозитории. 

### 1.26 Слияние в ветку master 
Я поддерживал соответствие ветки style с веткой master, теперь солью изменения style в ветку master. Теперь ветки style и master идентичны. 

![img26](screenshots/img26.png "git merge") 

### 1.27 Клонирование репозиториев 
Для клонирования репозиториев нужно перейти в рабочий каталог и с помощью комманды clone создать clone репозитория 

![img27](screenshots/img27.png "git clone") 

### 1.28 Просмотр клонированного репозитория 
Для этого перейдём в клонированный репозиторий. Я вижу все те же файлы, что и в исходном репозитории. 
![img28.1](screenshots/img28.1.png "cloned_hello") 

Далее просмотрим историю клонированного репозитория. Она совпадает с исходной 

![img28.2](screenshots/img28.2.png "git log") 

### 1.29 Что такое origin? 
Выполним команду git remote. Мы видим, что клонированный репозиторий знает об имени по умолчанию удаленного репозитория. Выполним команду git remote show origin. 

![img29](screenshots/img29.png "remote")  

Удалённые репозитории могут с тем же успехом указывать на репозиторий на той же машине. Нет ничего особенного в имени «origin», однако существует традиция использовать «origin» в качестве имени первичного централизованного репозитория (если таковой имеется). 

### 1.30 Удаленные ветки 
Для того, чтобы увидеть все ветки, в том числе удалённые, я выполнил следующую команду: git branch -a 

![img30](screenshots/img30.png "git branch") 

### 1.31 Изменение оригинального репозитория 
Я внес некоторые изменения в оригинальный репозиторий, чтобы затем попытаться извлечь и слить изменения из удаленной ветки в текущую. Для того, чтобы извлечь изменения я воспользовался командой git fetch 

![img31.1](screenshots/img31.1.png "fetch") 

На данный момент в клонированном репозитории есть все коммиты из оригинального репозитория, но они не интегрированы в локальные ветки клонированного репозитория. 
Команда git fetch будет извлекать новые коммиты из удаленного репозитория, но не будет сливать их с вашими наработками в локальных ветках. 
Можно посмотреть файл README.md и увидеть, что он не изменился 

![img31.2](screenshots/img31.2.png "README")

### 1.32 Слияние извлеченных изменений 
Для начала солью извлеченные изменения в локальную ветку master командой merge. Проверяю файл README и вижу, что он изменился 

![img32](screenshots/img32.png "git pull") 

Объединение fetch и merge в одну команду: pull 

### 1.33 Добавление ветки наблюдения 
Добавляю локальную ветку, которая отслеживает удаленную ветку. Для этого: 

![img33](screenshots/img33.png "git branch") 

### 1.34 Чистые репозитории 
Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания. Обычный git-репозиторий подразумевает, что вы будете использовать его как рабочую директорию, поэтому вместе с файлами проекта в актуальной версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории.git. В удаленных репозиториях нет смысла хранить рабочие файлы на диске, а все что им действительно нужно — это дель- 
ты изменений и другие бинарные данные репозитория. Вот это и есть «чистый репозиторий». 

### 1.35 Создайте чистый репозиторий 
Для создания чистого репозитория воспользуюсь командой 

![img35](screenshots/img35.png "git clone —bare") 

Как правило, репозитории, оканчивающиеся на .git являются чистыми репозиториями 

### 1.36 Добавление удаленного репозитория 
Добавляем репозиторий hello.git к нашему оригинальному репозиторию.

![img36](screenshots/img36.png "git remote add") 

### 1.37 Отправка изменений 
Для этого я отредактировал файл README.md и сделал коммит 
Затем отправил изменения в общий репозиторий 

![img37.1](screenshots/img37.1.png "git push") 

![img37.2](screenshots/img37.2.png "README.md") 

### 1.38 Извлечение общих изменений 
Для этого я выполнил ряд комманд 

![img38](screenshots/img38.png "git pull")

# Вывод 
    Ознакомился с основными возможностями git, а также научился работать с markdown